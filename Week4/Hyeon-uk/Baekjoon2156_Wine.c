/* ================================================================================================
 * Baekjoon Online Judge
 *		2156 - 포도주 시식
 *
 * time limit per test : 2 seconds
 * memory limit per test : 128 megabytes
 * standard input/standard output
 *
 * 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 
 * 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.
 *
 * 1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
 * 2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.
 *
 * 효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다.
 * 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고,
 * 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때,
 * 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오.
 *
 * ------------------------------------------------------------------------------------------------
 *
 * 포도주
 * dp[x][y] -> x번째 포도주를 먹은 후, y번째 포도주를 먹었을 때의 누적합
 * dp[0][1], dp[0][2], dp[0][3],
 * dp[1][2], dp[1][3], dp[1][4], ...
 * 일단 쭉 저장...
 * 탑다운 방식으로
 * 0, 1에서 시작
 * dp[0,1]
 * dp[0,2]
 * dp[0,3] 호출
 *
 * 다음에 dp[1,2], dp[1,3], dp[1,4] 호출...
 * dp[2,3], dp[2,4], dp[2,5] ...
 * 쭉 맨 마지막까지 내려가서 (깊이 10000)
 * dp[9999,10000]부터 dp 값 저장
 *
 * arr 0 1 2 3 4
 * eat 0 1 0 1 dc
 * eat 1 1 0 1 dc
 * eat 0 0 1 1 dc
 * eat 1 0 1 1 dc
 * eat 0 1 1 0 dc
 *
 *      0    1    2    3
 * eat  0    1    1   ...  -> dp[0] = 0, dp[1] = a[1], dp[2] = a[1] + a[2]
 *
 * 	    0    1    2    3
 * eat  0    1    1    0   -> dp[2]
 * eat  0    1    0    1   -> dp[1]        + a[3]
 * eat  0    0    1    1   -> dp[0] + a[2] + a[3]
 *
 * 	    1    2    3    4
 * eat  0    1    1    0   -> dp[3]
 * eat  0    1    0    1   -> dp[2]        + a[4]
 * eat  0    0    1    1   -> dp[1] + a[3] + a[4]
 *
 *     i-3  i-2  i-1   i
 * eat  x    1    1    0   -> dp[i-1]
 * eat  x    1    0    1   -> dp[i-2]          +  a[i]
 * eat  x    0    1    1   -> dp[i-3] + a[i-1] +  a[i]
 *
 * ------------------------------------------------------------------------------------------------ */

#include <stdio.h>

int max(int a, int b, int c) {
	if (a > b) {
		if (a > c)
			return a;
		else
			return c;
	}
	else {
		if (b > c)
			return b;
		else
			return c;
	}
}

int main(void) {
	int n;
	int dp[10001];
	int t;
	int ot = 0;
	scanf("%d", &n);
	dp[0] = 0;
	scanf("%d", &t);
	dp[1] = t;
	if (n > 1) {
		scanf("%d", &t);
		dp[2] = dp[1] + t;
		ot = t;
	}
	for (int i = 3; i <= n; i++) {
		scanf("%d", &t);
		dp[i] = max(dp[i - 1], dp[i - 2] + t, dp[i - 3] + ot + t);
		ot = t;
	}
	printf("%d\n", dp[n]);

	return 0;
}